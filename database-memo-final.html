<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>데이터베이스</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" as="style">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">

  <link rel="preload" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css" as="style">
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">

  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css">

  <style>
    body { max-width: 900px; padding: 30px; word-break: keep-all; line-height: 1.7; font-family: 'Noto Serif KR', serif; font-size: 16px; }
    h1, h2, h3, h4, h5, h6 { font-weight: 800; }
    h1 { font-size: 1.6em; border-bottom: 1px solid #000000; }
    h2 { font-size: 1.4em; }
    h3 { font-size: 1.2em; }
    h4, h5, h6 { font-size: 1em; }
    img { box-sizing: initial; width: auto; height: auto; max-width: 800px; max-height: 600px; display: block; margin: 0 0 1em 0; }
    ol, ul { padding-left: 2em; }
    ol ol, ol ul, ul ol, ul ul { margin: 0; }
    ul > li, ol > li { line-height: 1.7; }
    a { color: #0366d6; text-decoration: none; }
    a:hover { outline-width: 0; text-decoration: underline; }
    small { font-size: 85%; color: #6a737d; font-weight: normal; }
    h1 > code, h2 > code, li > code,  p > code { margin: 0; font-size: 90%; }
    blockquote { margin: 5px 0 0 0; padding: 0 15px; color: #6a737d; border-left: .25em solid #dfe2e5; }
    table { border-spacing: unset; border-collapse: collapse; margin: 0 0 1em 0; }
    th, td { padding: 5px 10px 5px 10px; border: 1px black solid; line-height: 1.3; }
    code { font-family: 'Fira Code', monospace; }
    .katex-display { overflow: auto; }
    .katex-display > .katex { text-align: left; }
    .hljs { line-height: 1.5; }
    .footnotes > .footnotes-list { padding: 0; counter-reset: list; font-size: 14px; }
    .footnotes > .footnotes-list > .footnote-item { list-style-position: inherit; list-style: none; }
    .footnotes > .footnotes-list > .footnote-item:before { content: "[" counter(list) "] "; counter-increment: list; }
    .footnotes > .footnotes-list > .footnote-item > p { display: inline; }
  </style>
</head>

<body>
  <h1 id="%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4" tabindex="-1">데이터베이스</h1>
<h2 id="functional-dependency-and-normalization" tabindex="-1">Functional Dependency and Normalization</h2>
<ul>
<li>데이터베이스의 품질을 측정하는 기준:
<ul>
<li>attribute semantics를 명확히 한다.</li>
<li>튜플의 중복된 정보를 최소화한다.</li>
<li>튜플의 NULL 값을 최소화한다.</li>
<li>위변조 튜플의 생성을 방지한다.</li>
</ul>
</li>
<li>각 튜플은 하나의 엔티티나 릴레이션십 인스턴스를 표현해야 함.</li>
</ul>
<h3 id="redundancy" tabindex="-1">Redundancy</h3>
<ul>
<li>중복 데이터는 저장 공간을 낭비.</li>
<li>Insertion anomalies</li>
<li>Deletion anomalies: 한 레코드를 지우려면 중복된 모든 레코드를 제거해야.</li>
<li>Update anomalies: 레코드의 내용을 변경하려면 중복된 모든 레코드를 변경해야.</li>
</ul>
<h3 id="null-values" tabindex="-1">Null values</h3>
<ul>
<li>NULL은 다양한 의미를 가짐.</li>
<li>테이블을 분리하면 NULL을 없앨 수 있다. (NULL 대신 아예 레코드가 없게 됨)</li>
<li>spurious tuples:
<ul>
<li>실제로 존재하지 않는 fake record.</li>
<li>조인을 잘못하면 spurious tuple이 생길 수 있음.</li>
</ul>
</li>
</ul>
<h3 id="functional-dependencies-(fd)" tabindex="-1">Functional Dependencies (FD)</h3>
<ul>
<li>relational design의 일반화된 formal measures of the goodness.</li>
<li>X가 Y를 functionally determine한다: X의 값이 Y의 유니크한 값을 결정하는 경우.
<ul>
<li>e.g., 학번이 같으면 이름이 같다.</li>
<li>FD는 존재할 수 있다(may exist)고 표현. 반례를 찾으면 존재하지 않는다(do not exist).</li>
</ul>
</li>
<li>테이블을 보고 FD가 존재할 수 있는지, 존재하지 않는지 판단할 수 있어야.</li>
</ul>
<h3 id="normalization" tabindex="-1">Normalization</h3>
<ul>
<li>‘나쁜’ 릴레이션을 쪼개 어트리뷰트들을 작은 릴레이션으로 나누는 것.</li>
<li>Normal Forms (NF):
<ul>
<li>포함관계: BCNF <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></eq> 3NF <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></eq> 2NF <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></eq> 1NF.</li>
<li>prime attribute: 후보키의 일부여야 한다.</li>
<li>nonprime attribute: prime attribute가 아닌 것들. 후보키의 일부도 아님.</li>
<li>decomposition할 때는 뭘로 조인할건지 고민해보면 된다.</li>
</ul>
</li>
</ul>
<h4 id="1st-nf" tabindex="-1">1st NF</h4>
<ul>
<li>모든 어트리뷰트가 키에 의존하는 형식.</li>
<li>composite attr, nested attr, multivalued relation이 없다면 1NF.</li>
<li>별도 릴레이션으로 분리하거나, 컬럼을 추가함으로써 해결할 수 있음.</li>
</ul>
<h4 id="2nd-nf" tabindex="-1">2nd NF</h4>
<p><img src="https://user-images.githubusercontent.com/6410412/244057741-f4e29ee6-9288-41c3-8a89-a6a711d01e97.png" alt=""></p>
<ul>
<li>모든 non-prime attr이 PK에 Fully FD한 형식.</li>
<li>더 일반화된 정의: 모든 non-prime attr이 모든 키에 Fully FD한 형식.</li>
<li>PK가 진짜 prime한 것만으로 구성되어 있는가?</li>
<li>Full FD: e.g., (Ssn, Pnumber) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> Hours. Ssn <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> Hours, Pnumber <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> Hours 둘 다 표현할 수 없으므로.</li>
<li>Not a Full FD (Partial dependency): e.g., (Ssn , Pnumber) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> Ename. Ssn <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> Ename으로 표현할 수 있으므로.</li>
<li>PK의 일부가 non-prime attr을 결정해서는 안 됨.</li>
<li>1NF를 만족한다.</li>
</ul>
<h4 id="3rd-nf" tabindex="-1">3rd NF</h4>
<p><img src="https://user-images.githubusercontent.com/6410412/244057854-7883362c-d387-4d61-a660-e042367f7ab9.png" alt=""></p>
<ul>
<li>어떠한 non-prime attr도 PK에 대해 transitively dependent하지 않은 형식.</li>
<li>Transitive FD: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></eq>는 두 FD, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></eq>와 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">Y \rightarrow Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></eq>로 유도할 수 있다.</li>
<li>transitive하다면 테이블을 분리할 수 있음.</li>
<li>FD 관계 X <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> A 에서 X가 SK이거나, A가 prime attr이라면 3NF를 만족한다.</li>
<li>non-prime attr이 다른 non-prime attr을 결정해서는 안 됨.</li>
<li>1NF와 2NF를 만족한다.</li>
</ul>
<h4 id="bcnf" tabindex="-1">BCNF</h4>
<ul>
<li>FD X <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> A에서 X가 SK인 형식.</li>
<li>키가 아닌 어트리뷰트가 결정자 역할을 한다면 분리해야 한다.</li>
<li>N개 컬럼에 대해 decomposition 방법이 N개가 있을 수 있다.</li>
<li>non-prime attr이 prime attr을 결정해서는 안 됨.</li>
<li>1NF, 2NF, 3NF를 만족한다.</li>
</ul>
<h2 id="indexing" tabindex="-1">Indexing</h2>
<ul>
<li>인덱싱은 거대한 데이터베이스를 효율적으로 검색하기 위한 데이터 구조.</li>
<li>두 가지 핵심 개념:
<ul>
<li>레코드를 디스크 블록에 매핑한다.</li>
<li>빠른 검색을 위해 부가적인(auxiliary) 데이터 구조를 유지한다.</li>
</ul>
</li>
<li>인덱스는 page id와 block address를 매핑해둔 auxiliary file.
<ul>
<li>기본적으로 &lt;field value, pointer to record&gt; 형태.</li>
<li>auxiliary data structure의 장점: raw data에 비해 같은 공간에 더 많은 정보를 저장해둘 수 있음.</li>
<li>단점: 인덱스 자체가 실제 데이터를 의미하지는 않으므로, 액세스가 한 번 더 필요함.</li>
</ul>
</li>
<li>인덱스의 성격을 dense와 sparse로 나눌 수 있음:
<ul>
<li>Dense:
<ul>
<li>모든 레코드가 인덱스 엔트리에 매핑되어 있는 경우.</li>
<li>이때 page id는 데이터의 순서와 동일, binary search하면 된다.</li>
<li>데이터가 정렬되어 있지 않다면 dense index를 사용해야 한다.</li>
</ul>
</li>
<li>Sparse (or nondense):
<ul>
<li>일부 레코드만 매핑되어 있는 경우.</li>
<li>데이터 블록당 하나의 키-포인터 쌍이 존재한다.</li>
<li>데이터가 정렬되어 있다면 sparse index를 사용해도 된다.</li>
</ul>
</li>
<li>인덱스는 sorted lists나 hashing으로 표현할 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="primary-index" tabindex="-1">Primary Index</h3>
<p><img src="https://user-images.githubusercontent.com/6410412/237427776-094fce65-b9e5-48f1-b04e-4f4dfa9636cf.png" alt=""></p>
<ul>
<li>정렬된 데이터를 위한 sparse index.</li>
<li>인덱스 엔트리가 각 블록의 첫 번째 레코드를 가리킨다.</li>
<li>record organization:
<ul>
<li>spanned: 레코드가 여러 블록에 걸쳐서 저장되는 경우. 레코드가 블록보다 클 때 필요하다.</li>
<li>unspanned: 레코드가 한 블록 안에만 저장되는 경우.</li>
</ul>
</li>
<li>인덱스 엔트리는 정렬되어 있으므로 binary search가 가능함.</li>
</ul>
<blockquote>
<p>예시(without primary index):</p>
<ul>
<li>r = 300000, b = 4096B</li>
<li>R = 100B on unspanned file</li>
<li>bfr = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>R</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor b / R \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">⌋</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mn>4096</mn><mn>100</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {4096 \over 100} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4096</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = 40 records per block.</li>
<li>num of blocks = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>r</mi><mtext>bfr</mtext></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {r \over \text{bfr}} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">bfr</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>300000</mn><mn>40</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {300000 \over 40} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">300000</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 7500 blocks.</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></eq> total number of blocks = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mn>7500</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log_2 7500 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7500</span><span class="mclose">⌉</span></span></span></span></eq> = 13.</li>
</ul>
</blockquote>
<blockquote>
<p>예시(with primary index):</p>
<ul>
<li>r = 300000, b = 4096B</li>
<li>R = 100B on unspanned file</li>
<li>V = 9B, P = 6B</li>
<li>bfr = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>R</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor b / R \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">⌋</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mn>4096</mn><mn>100</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {4096 \over 100} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4096</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = 40 records per block.</li>
<li>num of blocks = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>300000</mn><mn>40</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {300000 \over 40} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">40</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">300000</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 7500 blocks.</li>
<li>bfr for index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>b</mi><mrow><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {b \over (V + P)} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mn>4096</mn><mn>15</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {4096 \over 15} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4096</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = 273 entries per block.</li>
<li>num of blocks for index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>7500</mn><mn>273</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {7500 \over 273} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">273</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7500</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 28 blocks.</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></eq> total number of blocks = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mn>28</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log_2 28 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">28</span><span class="mclose">⌉</span></span></span></span></eq> = 5 + 1 = 6.</li>
</ul>
</blockquote>
<ul>
<li>인덱스 엔트리 수는 레코드 수보다 적다.</li>
<li>인덱스 엔트리 크기는 레코드 크기보다 작다. (인덱스의 V + P 값이 R 값보다 작음.)</li>
<li>따라서 데이터 레코드를 binary search 하는 것보다 인덱스를 탐색하는 편이 훨씬 효율적.</li>
</ul>
<h3 id="secondary-index" tabindex="-1">Secondary Index</h3>
<p><img src="https://user-images.githubusercontent.com/6410412/237428049-c2b58446-911a-41a3-bc27-7791b3458c34.png" alt=""></p>
<ul>
<li>primary index가 이미 있다고 가정, candidate keys에 사용하는 추가적인 인덱스.</li>
<li>정렬되지 않은 데이터를 위한 dense index. (물론 정렬된 경우에도 사용 가능.)</li>
<li>따라서 secondary index에는 레코드 수만큼의 엔트리가 필요하다.</li>
<li>인덱스는 두 개의 필드로 정렬되어 있음:
<ul>
<li>첫 번째 필드: 데이터 파일의 non-ordering field와 같은 데이터 타입.</li>
<li>두 번째 필드: block pointer 또는 record pointer 중 하나.</li>
</ul>
</li>
<li>엔트리 수가 많으므로 primary index보다 더 많은 공간과 탐색 시간을 필요로한다.</li>
<li>하지만 정렬되지 않은 임의의 레코드에 대한 탐색 시간을 개선해줌.</li>
</ul>
<blockquote>
<p>예시:</p>
<ul>
<li>r = 300000, b = 4096B</li>
<li>R = 100B on unspanned file</li>
<li>V = 9B, P = 6B</li>
<li>bfr = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>b</mi><mrow><mo stretchy="false">(</mo><mi>V</mi><mo>+</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {b \over (V + P)} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4001em;vertical-align:-0.52em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mn>4096</mn><mn>15</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {4096 \over 15} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4096</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = 273 entries per block.</li>
<li>num of blocks for index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mn>300000</mn><mi mathvariant="normal">/</mi><mn>273</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil 300000 / 273 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord">300000/273</span><span class="mclose">⌉</span></span></span></span></eq> = 1099 blocks. (dense)</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></eq> total number of blocks = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mn>1099</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log_2 1099 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1099</span><span class="mclose">⌉</span></span></span></span></eq> = 11 + 1 = 12.</li>
</ul>
</blockquote>
<h3 id="multi-level-secondary-index" tabindex="-1">Multi-level Secondary Index</h3>
<ul>
<li>페이지 당 하나의 엔트리를 두려면 많은 저장공간이 필요함.</li>
<li>만약 secondary index가 엄청 커진다면?</li>
<li>인덱스의 인덱스를 만들면 더 적은 접근으로 데이터를 찾을 수 있다.</li>
</ul>
<blockquote>
<p>예시:</p>
<ul>
<li>r = 300000, b = 4096B</li>
<li>R = 100B on unspanned file</li>
<li>V = 9B, P = 6B</li>
<li>bfr = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mn>4096</mn><mn>15</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {4096 \over 15} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4096</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌋</span></span></span></span></eq> = 273 entries per block.</li>
<li>num of blocks for index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>300000</mn><mn>273</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {300000 \over 273} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">273</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">300000</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 1099 blocks. (dense)</li>
<li>num of blocks for 2nd-level index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>1099</mn><mn>273</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {1099 \over 273} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">273</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1099</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 5 blocks.</li>
<li>num of blocks for 3rd-level index = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mn>5</mn><mn>273</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {5 \over 273} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">273</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">⌉</span></span></span></span></eq> = 1 block.</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></eq> total number of blocks = 3 + 1 = 4.</li>
</ul>
</blockquote>
<h2 id="b-tree%3A-dynamic-multi-level-index" tabindex="-1">B-Tree: Dynamic Multi-level Index</h2>
<ul>
<li>multi-level index를 동적으로 관리(추가/삭제)하기 위한 자료구조.</li>
<li>binary tree가 하나의 인덱스만 갖는다면, b-tree에는 여러 개의 인덱스가 있음.</li>
<li>properties of b-tree:
<ul>
<li>balanced tree.</li>
<li>q 범위 노드에는 q - 1개의 키가 있음.</li>
<li>최소 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">q / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">/2</span></span></span></span></eq> 개의 엔트리가 있어야. (루트가 아닌 경우)</li>
<li>루트부터 리프까지의 거리가 모두 같음.</li>
</ul>
</li>
<li>포인터를 따라가며 탐색한다: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>B</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_B(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>, 이때 B는 블록 당 엔트리 개수. 이걸 order of b-tree라고 한다.</li>
</ul>
<h2 id="b%2Btree%3A-optimizing-b-tree" tabindex="-1">B+Tree: Optimizing B-Tree</h2>
<ul>
<li>b-tree는 트리의 모든 노드에 레코드를 가리키는 포인터가 있음:
<ul>
<li>반면 b+tree는 리프 노드만 data pointer를 가짐. internal node는 tree pointer만을 갖는다.</li>
<li>또한 leaf node가 다른 leaf node를 가리킨다.</li>
</ul>
</li>
<li>무조건 리프 노드에 도달할 수 있으므로 항상 같은 복잡도를 보장할 수 있음.</li>
<li>higher-capacity indexes: <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq>개의 키로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></eq> 범위를 정의할 수 있음.</li>
<li>리프 노드가 링크드리스트를 이루고 있어서 빠르게 범위 탐색을 할 수 있음.</li>
</ul>
<h2 id="other-indexing-structures" tabindex="-1">Other Indexing Structures</h2>
<ul>
<li>Hash-Based file Organization:
<ul>
<li>O(1) 시간복잡도.</li>
<li>범위를 기준으로 검색하려면 결국 모든 노드를 살펴봐야 한다.</li>
</ul>
</li>
<li>R+Tree:
<ul>
<li>b+tree와 비슷한데 공간 데이터를 위한 자료구조.</li>
<li>나와 가까운 매장찾기, 이런 거 minimum bounding box를 이용해 저장.</li>
</ul>
</li>
</ul>
<h2 id="introduction-to-transaction-processing-concepts-and-theory" tabindex="-1">Introduction to Transaction Processing Concepts and Theory</h2>
<h3 id="transaction-basics" tabindex="-1">Transaction Basics</h3>
<ul>
<li>트랜잭션은 데이터베이스 프로세싱의 논리적 단위.</li>
<li>하나의 트랙잭션이 하나 이상의 명령을 포함할 수도 있음. (e.g., 한 건의 계좌이체에 잔고 확인, 이체, 잔고 갱신의 과정이 포함됨.)</li>
<li>시스템에서 가장 기본적인 명령은 읽기, 쓰기 뿐.</li>
<li>ACID: 데이터베이스 시스템을 사용하는 이유이기도.
<ul>
<li>Atomicity:
<ul>
<li>트랜잭션은 하나의 단위로 커밋되거나, 롤백된다.</li>
<li>위협: 시스템 실패, 책임: recovery manager</li>
</ul>
</li>
<li>Consistency:
<ul>
<li>데이터는 항상 정해진 규칙을 만족해야 한다.</li>
<li>위협: 트랜잭션 로직 에러, 책임: 프로그래머</li>
</ul>
</li>
<li>Isolation:
<ul>
<li>트랜잭션이 서로 영향을 미쳐서는 안 된다. (independent하다는 건 아님!)</li>
<li>위협: 동시적 실행, 책임: concurrency control manager</li>
</ul>
</li>
<li>Durability:
<ul>
<li>커밋된 데이터는 물리적인 상황(전원이 꺼지는 등)에도 유지되어야 한다.</li>
<li>위협: 시스템 실패, 책임: recovery manager</li>
</ul>
</li>
</ul>
</li>
<li>Transaction State
<ul>
<li>에러 등으로 partially commit되는 경우, 시스템이 어느 부분에서 에러가 발생했는지 체크하고 롤백한다.</li>
<li>Three types of transaction life:
<ul>
<li>Successful</li>
<li>Application requests termination</li>
<li>Forced termination</li>
</ul>
</li>
<li>사용자가 버튼을 잘못 누른 경우 트랜잭션을 중단해야 함.</li>
</ul>
</li>
<li>Reovery manager:
<ul>
<li>Commit: 트랜잭션이 성공한 경우. 커밋되면 되돌릴 수 없음.</li>
<li>Rollabck (or abort): 트랜잭션이 실패한 경우.</li>
</ul>
</li>
</ul>
<h3 id="how-to-schedule-transaction" tabindex="-1">How to schedule transaction</h3>
<ul>
<li>동시성에 대해 생각해보자:
<ul>
<li>Interleaved processing: 하나의 CPU에서 여러 작업을 번갈아 실행.</li>
<li>Parallel processing: 여러 CPU에서 여러 작업을 동시에 실행.</li>
</ul>
</li>
<li>Transaction management가 필요한 이유:
<ul>
<li>Lost udpate problem: 업데이트되기 전 데이터를 기준으로 덮어쓰는 문제.
<img src="https://user-images.githubusercontent.com/6410412/244058042-87ab1c64-baf3-4aa2-a81b-79848a8e64e7.png" alt=""></li>
<li>Temporary update (dirty read) problem: 데이터가 변경되기 전에 읽는 문제.
<img src="https://user-images.githubusercontent.com/6410412/244058067-46f32377-74a9-4ae8-9c6e-ff6db1d4a0af.png" alt=""></li>
<li>Incorrect summary problem: 집계 후 데이터가 변경되어 잘못된 결과를 얻는 문제.
<img src="https://user-images.githubusercontent.com/6410412/244058089-0345aaff-65fc-47ea-8a6b-607f87786088.png" alt=""></li>
</ul>
</li>
<li>트랜잭션을 어떻게 스케줄링할 것인가?
<ul>
<li>트랜잭션 간 순서를 조정한다.</li>
<li>순차(serial) 실행한다:
<ul>
<li>한 트랜잭션이 끝난 다음에 다른 트랜잭션을 수행하도록 한다.</li>
<li>단, 어떤 트랜잭션이 먼저 실행될지는 보장할 수는 없다.</li>
</ul>
</li>
</ul>
</li>
<li>Serializability of Transactions:
<ul>
<li>Equivalent schedule: 두 스케줄의 효과가 동일한 경우 equivalent.</li>
<li>Serializable schedule: 트랜잭션의 순차 실행과 equivalent한 스케줄.</li>
<li>serializable한 것은 serial한 것과 같지 않다.</li>
<li>serializable하다는 것은 그 스케줄이 올바른 스케줄이라는 것.</li>
</ul>
</li>
<li>Anomalies for interleaved schedules:
<img src="https://user-images.githubusercontent.com/6410412/244058307-b3226614-640a-44c4-ac43-46f7fd62d64f.png" alt="">
<ul>
<li>오퍼레이션을 수행하며 conflict가 발생할 수 있음:
<ul>
<li>서로 다른 트랜잭션이 하나의 아이템에 접근할 때.</li>
<li>적어도 하나의 write operation이 있는 경우.</li>
</ul>
</li>
<li>RW conflict: 값이 변경되기 전에 읽는 문제.</li>
<li>WR conflict (dirty read): 커밋되지 않은 값을 읽는 문제.</li>
<li>WW conflict: 아직 커밋되지 않은 데이터를 덮어쓰는 문제.</li>
</ul>
</li>
<li>Serializability testing:
<ul>
<li>트랜잭션 사이 그래프를 그려 serializable한지 확인할 수 있음:
<ul>
<li>T1이 W(X)하고, T2가 R(X): T1 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> T2</li>
<li>T1이 R(X)하고, T2가 W(X): T1 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> T2</li>
<li>T1이 W(X)하고, T2가 W(X): T1 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></eq> T2</li>
</ul>
</li>
<li>사이클이 없다면 안전하게 serializable schedule을 할 수 있음.</li>
</ul>
</li>
</ul>
<h3 id="transaction-support-in-rdbms" tabindex="-1">Transaction Support in RDBMS</h3>
<ul>
<li>SQL에서는 하나의 SQL 구문이 atomic하다.</li>
<li>모든 트랜잭션은 COMMIT 또는 ROLLBACK 구문으로 끝을 명시해야 함.</li>
<li>Transaction isolation levels:
<img src="https://user-images.githubusercontent.com/6410412/244058337-79be4ff0-6af3-487f-af62-ef93eacf44df.png" alt="">
<ul>
<li>트랜잭션의 격리 수준을 설정할 수 있음.</li>
<li>dirty write는 어떠한 격리 수준도 허용하지 않음.</li>
<li>SERIALIZABLE은 가장 높은 격리 수준, SELECT 쿼리만 실행해도 데이터에 락이 걸림.</li>
</ul>
</li>
<li>Drity read: 다른 트랜잭션에서 아직 커밋되지 않은 값을 읽을 수 있음.</li>
<li>Nonrepeatable raed: 한 트랜잭션에서 여러 번 read했을 때 모두 다른 값을 읽을 수 있음.</li>
<li>Phantom read: nonrepeatable의 일종, 여러 번 read했을 때 값이 없었다가 생기거나, 있었다가 없어질 수 있음.</li>
</ul>
<h2 id="concurrency-control" tabindex="-1">Concurrency Control</h2>
<ul>
<li>트랜잭션 매니저와 락 매니저가 동시성 컨트롤 담당.</li>
<li>동시성 컨트롤의 목적:
<ul>
<li>트랜잭션 사이 isolation을 강제.</li>
<li>RW, WW conflicts를 해결.</li>
<li>시스템의 consistency를 유지.</li>
</ul>
</li>
</ul>
<h3 id="locking-basics" tabindex="-1">Locking Basics</h3>
<h4 id="binary-locks" tabindex="-1">Binary Locks</h4>
<ul>
<li>각 트랜잭션은 데이터를 읽거나 쓰기 전에 락을 얻어야 한다.</li>
<li>락을 통해 스케줄러는 conflict-serializability를 보장할 수 있다.</li>
<li>두 가지 atomic opertaions: <code>lock(x)</code>, <code>unlock(x)</code></li>
<li>읽기, 쓰기 전에 아이템 <code>x</code>에 락을 걸고, 이후에는 락을 해제한다.</li>
<li>이미 아이템 <code>x</code>가 락을 점유하고 있다면 대기한다.</li>
<li>RW, WW conflicts는 방지할 수 있음.</li>
</ul>
<pre class="hljs"><code>    lock_itme(x):
B:    if LOCK(x) = 0
        then LOCK(x) ← 1
      else
        begin
        wait (until LOCK(x) == 0
          and the lock manager wakes up the transaction);
        goto B
        end;
</code></pre>
<pre class="hljs"><code>unlock_itme(x):
  LOCK(x) ← 0
  if any transactions are waiting
    wakeup one of the waiting transactions;
</code></pre>
<ul>
<li>트랜잭션은 read(x) 또는 write(x) 전에 반드시 lock_item(x)를 해야 함.</li>
<li>read(x) 또는 write(x)를 마치면 unlock_item(x)을 해야 함.</li>
<li>이미 x에 락이 걸려있으면 lock_item(x)을 할 수 없으므로 락 매니저가 깨울 때까지 대기한다.</li>
</ul>
<h4 id="shared-%2F-exclusive-locks" tabindex="-1">Shared / Exclusive Locks</h4>
<ul>
<li>애초에 RR에는 conflict가 발생하지 않는데 이때도 락이 필요할까?</li>
<li>읽기용, 쓰기용 락을 분리하자.</li>
<li>Shared (read lock):
<ul>
<li>여러 아이템이 read lock을 획득할 수 있음.</li>
<li>누군가 write lock을 점유하고 있으면 획득할 수 없음.</li>
<li>reader가 몇 개인지 저장해두고, unlock할 때 0이 되면 대기 중인 트랜잭션을 깨운다.</li>
</ul>
</li>
<li>Exclusive (write lock):
<ul>
<li>누군가 write lock을 점유하고 있으면 획득할 수 없음.</li>
<li>누군가 read lock을 점유하고 있으면 획득할 수 없음.</li>
</ul>
</li>
<li>linked list 형태로 lock table을 관리한다.</li>
</ul>
<pre class="hljs"><code>    read_lock(x):
B:    if LOCK(x) = &quot;unlocked&quot;
        then begin LOCK(x) ← &quot;read-locked&quot;
          no_of_reads(x) ← 1
        end
      else if LOCK(x) = &quot;read-locked&quot;
        then no_of_reads(x) ← no_of_reads(x) + 1
      else begin
        wait (until LOCK(x) = &quot;unlocked&quot;
          and the lock manager wakes up the transaction);
        goto B
        end;
</code></pre>
<pre class="hljs"><code>    write_lock(x):
B:    if LOCK(x) = &quot;unlocked&quot;
        then LOCK(x) ← &quot;write-locked&quot;
      else begin
        wait (until LOCK(x) = &quot;unlocked&quot;
          and the lock manager wakes up the transaction);
        goto B
        end;
</code></pre>
<pre class="hljs"><code>unlock(x):
  if LOCK(x) = &quot;write-locked&quot;
      then begin LOCK(x) ← &quot;unlocked&quot;;
        wakeup one of the waiting transactions, if any
        end
  else if LOCK(x) = &quot;read-locked&quot;
    then begin
      no_of_reads(x) ← no_of_reads - 1;
      if no_of_reads(x) = 0
        then begin LOCK(x) = &quot;unlocked&quot;;
          wakeup one of the waiting transactions, if any
          end
      end;
</code></pre>
<h3 id="two-phase-locking" tabindex="-1">Two-Phase Locking</h3>
<p><img src="https://user-images.githubusercontent.com/6410412/244058362-9eee33fc-a80f-4e94-b737-9240afe818bd.png" alt=""></p>
<ul>
<li>앞서 shared / exclusive locks를 나이브하게 쓰면 값이 최신인지 보장할 수가 없음.</li>
<li>두 개의 mutually exclusive한 phase가 있어야 함:
<ul>
<li>2PL에는 growing phase와 shringking phase가 있다.</li>
<li>growing phase: 락을 얻기만 한다.</li>
<li>shrinking phase: 락을 해제하기만 한다.</li>
</ul>
</li>
<li>데드락 문제가 발생할 수 있음.</li>
<li>Strict 2PL:
<ul>
<li>트랜잭션이 종료된 이후에 사용한 모든 락을 해제하는 방식.</li>
<li>2PL 알고리즘에 주로 사용.</li>
<li>데드락의 가능성이 있음.</li>
</ul>
</li>
<li>Conservative 2PL:
<ul>
<li>트랜잭션이 시작하기 전에 필요한 모든 락을 획득, 종료 후에 사용한 모든 락을 해제하는 방식.</li>
<li>데드락 문제가 없음.</li>
<li>데드락이 예상되면 트랜잭션 시작이 지연되기 때문에 동시성이 저해될 수 있음.</li>
</ul>
</li>
<li>데드락을 어떻게 해결할 것인가?
<ul>
<li>Prevention:
<ul>
<li>트랜잭션 시작 전에 모든 아이템을 락한다.</li>
<li>트랜잭션이 대기하지 않게 되므로 데드락을 방지할 수 있음.</li>
<li>Conservative 2PL의 접근법.</li>
</ul>
</li>
<li>Detection:
<ul>
<li>wait-for graph, 타임아웃.</li>
<li>이때 영원히 대기만 하는 starvation problem이 발생할 수 있음.</li>
<li>priority 기반 스케줄링 메커니즘에 내재된 문제, 우선순위 조정 필요.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="timestamp-based-protocol" tabindex="-1">Timestamp-Based Protocol</h3>
<ul>
<li>트랜잭션이 시스템에 들어올 때 타임스탬프를 발급한다.
<ul>
<li>트랜잭션 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>는 타임스탬프 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TS(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TS</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>를 갖는다.</li>
<li>타임스탬프가 강하게 단조 증가한다는 전제.</li>
</ul>
</li>
<li>타임스탬프는 serializability order를 결정한다.</li>
<li>각 데이터 Q는 두 개의 타임스탬프 값을 갖는다:
<ul>
<li>W-timestamp(Q): 가장 최근에 성공한 쓰기 타임스탬프.</li>
<li>R-timestamp(Q): 가장 최근에 성공한 읽기 타임스탬프.</li>
</ul>
</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>가 read(Q)를 하는 경우:
<ul>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TS(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TS</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> &lt; W-timestamp(Q):
<ul>
<li>Q가 다른 트랜잭션에 의해 덮어씌워졌을 것.</li>
<li>read(Q)를 리젝하고, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>를 롤백한다.</li>
</ul>
</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TS(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TS</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> &gt;= W-timestamp(Q): read(Q)를 실행하고, R-timestamp(Q)를 갱신.</li>
</ul>
</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>가 write(Q)를 하는 경우:
<ul>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TS(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TS</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> &lt; R-timestamp(Q):
<ul>
<li>다른 트랜잭션에서 dirty read가 일어났을 가능성.</li>
<li>write(Q)를 리젝하고, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>를 롤백한다.</li>
</ul>
</li>
<li><eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>S</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TS(T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TS</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq> &lt; W-timestamp(Q):
<ul>
<li>다른 트랜잭션이 작성한 최신 값을 덮어쓸 가능성.</li>
<li>write(Q)를 리젝하고, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></eq>를 롤백한다.</li>
</ul>
</li>
<li>그 외: write(Q)를 실행하고, W-timestamp(Q)를 갱신.</li>
</ul>
</li>
</ul>
<h2 id="nosql" tabindex="-1">NoSQL</h2>
<ul>
<li>데이터 준비(ETL):
<ol>
<li>Extract: 소스(파일, DB, 로그 등)에서 데이터를 추출.</li>
<li>Transform: 데이터를 변환.</li>
<li>Load: 싱크(Python, R, SQLite, RDBMS 등)로 데이터 적재.</li>
</ol>
</li>
<li>Tabular Data: 로우와 컬럼의 집합으로 구성된 데이터 포맷 (e.g., Excel, CSV)</li>
<li>XML: 인간과 기계가 모두 읽을 수 있는 데이터 포맷.</li>
<li>JSON:
<ul>
<li>self-describing 스키마.</li>
<li>Relational model과 달리 nested arrays 구조.</li>
<li>XML과 달리 타입이 있고 단순함.</li>
</ul>
</li>
<li>NoSQL:
<ul>
<li>RDBMS 원칙을 따르지 않는 모든 데이터베이스를 가리키는 용어.</li>
<li>Non-SQL (or No RDBMS), Not Only SQL.</li>
<li>주로 unstructured large-scale 데이터를 다루는 데이터베이스.</li>
</ul>
</li>
<li>Non-relational DBMS는 새로운 개념이 아님:
<ul>
<li>분산, 병렬 컴퓨팅 환경에서 확장 가능한 애플리케이션을 만들기 위한 시도.</li>
<li>구글 파일 시스템(2003), MapReduce(2004)가 있었고, 이후 Hadoop, Dynamo가 등장.</li>
</ul>
</li>
<li>NoSQL은 빅데이터와 관련되어 언급된다:
<ul>
<li>엄청나게 많은 데이터를 분산, 병렬 처리해야 해야 한다.</li>
<li>변화하는 비정형 데이터를 관리하는 것은 어려운 일임.</li>
<li>fault tolerance와 backup 외에도 효율적으로 데이터를 관리해야 함.</li>
</ul>
</li>
<li>Brewer’s CAP Theorem:
<ul>
<li>Consistency: 모든 클라이언트가 최신 데이터를 받을 수 있음.</li>
<li>Availability: 각 요청이 항상 응답을 받을 수 있음.</li>
<li>Partition-Tolerance: 노드간 네트워크 단절에도 시스템을 유지할 수 있음.</li>
<li>분산 데이터 스토어는 이 중 하나를 희생할 수 밖에 없다:
<ul>
<li>CA: RDBMS</li>
<li>AP: DynamoDB, CouchDB, Cassandra</li>
<li>CP: MongoDB, HBase, Redis</li>
</ul>
</li>
</ul>
</li>
<li>KV store, Document store, Wide column store, Graph store 등.</li>
</ul>
<h2 id="mapreduce-and-hadoop" tabindex="-1">MapReduce and Hadoop</h2>
<ul>
<li>무엇을 빅데이터라고 하는가?</li>
<li>3V of Big Data:
<ul>
<li>Volume: 일단 양이 많음.</li>
<li>Variety: 다양한 종류와 형식.</li>
<li>Velocity: 리얼타임, 스트리밍 (e.g., 지진 일어나면 경보보다 지진희 갤러리가 먼저 반응함.)</li>
</ul>
</li>
<li>4V of Big Data: 3V + Veracity (불확실성, 신뢰성)</li>
<li>5V of Big Data: 4V + Value (영향력, 실용성)</li>
<li>데이터 분석:
<ul>
<li>inspecting, cleansing, transforming, modeling 과정.</li>
<li>descriptive(현재), predictive(미래), prescriptive(액션플랜)</li>
</ul>
</li>
<li>데이터 마이닝: 데이터에서 중요한 패턴과 지식을 추출.</li>
<li>Scale-up(vertical) vs Scale-out(horizontal):
<ul>
<li>Scale-up:
<ul>
<li>리소스를 추가해 컴퓨팅 capacity를 높이는 것.</li>
<li>캐파가 늘수록 비용은 지수 증가.</li>
<li>노드 레벨 성능에 제한이 있을 때. (e.g., 데이터를 나눠 분산 저장할 수 없을 때)</li>
<li>반복적으로 증가하는 워크로드를 다룰 때.</li>
<li>작은 데이터셋을 구성할 때.</li>
<li>향후 3-5년간 데이터셋이 증가하지 않을 때.</li>
</ul>
</li>
<li>Scale-out:
<ul>
<li>아키텍처에 capacity를 추가하는 것.</li>
<li>캐파가 늘수록 비용은 선형 증가.</li>
<li>여러 저장소 노드에 워크로드를 분산해야 할 때.</li>
<li>지속적인 데이터의 증가가 예상될 때.</li>
</ul>
</li>
</ul>
</li>
<li>Hadoop:
<ul>
<li>데이터 저장소(S3, CouchDB)와 프로세싱(Spark, EC2) 영역에 해당.</li>
<li>방대한 데이터는 싱글 노드로 모두 처리할 수 없다.</li>
<li>노드가 죽어도 영속적으로 데이터를 저장하려면 분산 파일 시스템을 사용해야.</li>
<li>Hadoop Distributed File System (HDFS):
<ul>
<li>고대역폭, 고가용성 분산 스토리지.</li>
<li>NameNode-DataNode로 구성된 Master-Slave 아키텍처.</li>
<li>NameNode는 적어도 하나의 레플리카를 다른 랙에 저장한다.</li>
</ul>
</li>
<li>Hadoop MapReduce:
<ul>
<li>분산 빅데이터 처리 인프라.</li>
<li>데이터 파티셔닝, 프로그램 스케줄링 등.</li>
<li>MapReduce Paradigm: Map 함수와 Reduce 함수로 데이터를 처리.</li>
<li>Map: 리스트의 모든 요소에 함수를 적용. 추출.</li>
<li>Reduce: 리스트의 모든 요소를 합침. 집계.</li>
<li>프로그래머가 Map 함수와 Reduce 함수만 작성하면 원하는 처리가 가능.</li>
<li>만약 R, S 테이블을 조인하고 싶다면:
<ol>
<li>R(a, b)를 (b, (a, R))로 매핑.</li>
<li>S(b, c)를 (b, (c, S))로 매핑.</li>
<li>하둡이 자동으로 Reduce 프로세스 실행.</li>
<li>b를 기준으로 조인해 (a, b, c) 반환.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Hive:
<ul>
<li>HDFS에 저장된 방대한 데이터를 쿼리하기 위한 데이터 웨어하우스 시스템.</li>
<li>하이브에 SQL-like 쿼리를 보내면 Hive가 MapReduce 태스크를 실행해 하둡에 전송.</li>
<li>장점: 대량 데이터 처리가 쉽고, SQL 기반 쿼리 가능.</li>
<li>단점: 데이터를 추가하기 어렵고, HDFS의 파일이 이뮤터블함.</li>
</ul>
</li>
</ul>
<h2 id="mongodb" tabindex="-1">MongoDB</h2>
<ul>
<li>Document stores: self-describing, hierarchical tree data structures, XML, JSON 등.</li>
<li>전통적인 relational model보다 유연하다.</li>
<li>MongoDB: Hash-based, scheme-less database.</li>
<li>JSON은 사실 전송에 적합, 그래서 빠르고 저장에 적합한 BSON(Binary JSON)을 사용.</li>
<li>인덱스를 알아서 잡아준다, 샤딩도 알아서 해줌.</li>
</ul>

  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad:true });</script>
</body>

